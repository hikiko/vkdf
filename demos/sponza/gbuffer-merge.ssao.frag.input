#version 450

#extension GL_ARB_separate_shader_objects : enable

INCLUDE(../../data/glsl/lighting.glsl)

INCLUDE(../../data/glsl/util.glsl)

float calc_ao(in sampler2D ssao_tex, in sampler2D depth_tex, in sampler2D depth_low_tex, in vec2 in_uv)
{
   /* texture offset needs to be a compile time constant and so we can't
    * use a loop for the following steps, unfortunately.
    */

   float d0 = texture(depth_tex, in_uv).x;

   /* calculating the distances between the depths of the pixels
    * in the lowres neighborhood and the full res depth value
    * (texture offset must be compile time constant and so we
    * can't use a loop)
    */

   float depth1 = textureOffset(depth_low_tex, in_uv, ivec2(0, 0)).x;
   float depth2 = textureOffset(depth_low_tex, in_uv, ivec2(0, 1)).x;
   float depth3 = textureOffset(depth_low_tex, in_uv, ivec2(1, 0)).x;
   float depth4 = textureOffset(depth_low_tex, in_uv, ivec2(1, 1)).x;

   float min_depth = min(min(depth1, depth2), min(depth3, depth4));
   float max_depth = max(max(depth1, depth2), max(depth3, depth4));

   float step_distance = max_depth - min_depth;
   float s = 1 - step(0.00012, step_distance);
   //return s;

   /* distances */
   float d1 = abs(d0 - depth1);
   float d2 = abs(d0 - depth2);
   float d3 = abs(d0 - depth3);
   float d4 = abs(d0 - depth4);

   float dmin = min(min(d1, d2), min(d3, d4));

   float nearest;
   if (dmin == d1)
      nearest = depth1;

   if (dmin == d2)
	   nearest = depth2;

   if (dmin == d3)
      nearest = depth3;

   if (dmin == d4)
	   nearest = depth4;

   float ao = texture(ssao_tex, in_uv).x;
   return mix(nearest, ao, s);
}

layout(push_constant) uniform pcb {
   mat4 Proj;
   float aspect_ratio;
   float tan_half_fov;
} PCB;

layout(location = 0) in vec2 in_uv;
layout(location = 1) in vec2 in_view_ray;

layout(std140, set = 0, binding = 0) uniform ubo_camera {
   mat4 View;
   mat4 ViewInv;
} CD;

layout(std140, set = 1, binding = 0) uniform light_ubo
{
   Light sun;
} L;

struct ShadowMapData {
   mat4 light_viewproj;
   uint shadow_map_size;
   uint pfc_kernel_size; /* Overriden by specialization constant */
};

layout (constant_id = 0) const int SHADOW_MAP_PCF_KERNEL_SIZE = 2;

layout(std140, set = 1, binding = 1) uniform ubo_shadow_map_data {
   ShadowMapData shadow_map_data;
} SMD;

layout(std140, set = 1, binding = 2) uniform ubo_light_eye_space_data {
   vec4 eye_pos;
   vec4 eye_dir;
} LESD;

layout(set = 2, binding = 0) uniform sampler2DShadow shadow_map;

layout(set = 3, binding = 0) uniform sampler2D tex_depth;
layout(set = 3, binding = 1) uniform sampler2D tex_eye_normal;
layout(set = 3, binding = 2) uniform sampler2D tex_diffuse;
layout(set = 3, binding = 3) uniform sampler2D tex_specular;
layout(set = 3, binding = 4) uniform sampler2D tex_ssao;
layout(set = 4, binding = 0) uniform sampler2D tex_depth_lowres;

layout(location = 0) out vec4 out_color;

void main()
{
	float ao = calc_ao(tex_ssao, tex_depth, tex_depth_lowres, in_uv);
	out_color = vec4(ao, ao, ao, 1.0);
}
