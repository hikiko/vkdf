#version 450

#extension GL_ARB_separate_shader_objects : enable

INCLUDE(../../data/glsl/lighting.glsl)

INCLUDE(../../data/glsl/util.glsl)

float nearest_depth_occlusion(in sampler2D ssao_tex,
                              in sampler2D depth_tex,
                              in sampler2D depth_low_tex,
                              in vec2 in_uv)
{
   /* texture offset needs to be a compile time constant and so we can't
    * use a loop for the following steps, unfortunately.
    */

   float d0 = texture(depth_tex, in_uv).x;

   /* calculating the distances between the depths of the pixels
    * in the lowres neighborhood and the full res depth value
    * (texture offset must be compile time constant and so we
    * can't use a loop)
    */

   float d1 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(0, 0)).x);
   float d2 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(0, 1)).x);
   float d3 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(1, 0)).x);
   float d4 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(1, 1)).x);

   float dmin = min(min(d1, d2), min(d3, d4));

   if (dmin == d1)
      return textureOffset(ssao_tex, in_uv, ivec2(0, 0)).x;

   if (dmin == d2)
      return textureOffset(ssao_tex, in_uv, ivec2(0, 1)).x;

   if (dmin == d3)
      return textureOffset(ssao_tex, in_uv, ivec2(1, 0)).x;

   if (dmin == d4)
      return textureOffset(ssao_tex, in_uv, ivec2(1, 1)).x;
}

float select_ambient_occlusion(in sampler2D ssao_tex,
                               in sampler2D depth_tex,
                               in sampler2D low_normal_tex,
                               in sampler2D low_depth_tex,
                               in vec2 in_uv)
{
   /* taking the normals of the neighborhood */
   vec3 n0 = textureOffset(low_normal_tex, in_uv, ivec2(0, 0)).xyz;
   vec3 n1 = textureOffset(low_normal_tex, in_uv, ivec2(0, 1)).xyz;
   vec3 n2 = textureOffset(low_normal_tex, in_uv, ivec2(1, 0)).xyz;
   vec3 n3 = textureOffset(low_normal_tex, in_uv, ivec2(1, 1)).xyz;

   /* we need to find the maximum dot product */
   float d0 = abs(dot(n0, n1));
   float d1 = abs(dot(n0, n2));
   float d2 = abs(dot(n0, n3));

   float max_dot = max(d0, max(d1, d2));
   float selection = step(0.81, max_dot);

   float lerp_occlusion = texture(ssao_tex, in_uv).x;
   float best_depth_occlusion = nearest_depth_occlusion(ssao_tex, depth_tex, low_depth_tex, in_uv);
   return mix(lerp_occlusion, best_depth_occlusion, step(0.895, max_dot));
   //return lerp_occlusion;
   //return best_depth_occlusion;
}

layout(push_constant) uniform pcb {
   mat4 Proj;
   float aspect_ratio;
   float tan_half_fov;
} PCB;

layout(location = 0) in vec2 in_uv;
layout(location = 1) in vec2 in_view_ray;

layout(std140, set = 0, binding = 0) uniform ubo_camera {
   mat4 View;
   mat4 ViewInv;
} CD;

layout(std140, set = 1, binding = 0) uniform light_ubo
{
   Light sun;
} L;

struct ShadowMapData {
   mat4 light_viewproj;
   uint shadow_map_size;
   uint pfc_kernel_size; /* Overriden by specialization constant */
};

layout (constant_id = 0) const int SHADOW_MAP_PCF_KERNEL_SIZE = 2;

layout(std140, set = 1, binding = 1) uniform ubo_shadow_map_data {
   ShadowMapData shadow_map_data;
} SMD;

layout(std140, set = 1, binding = 2) uniform ubo_light_eye_space_data {
   vec4 eye_pos;
   vec4 eye_dir;
} LESD;

layout(set = 2, binding = 0) uniform sampler2DShadow shadow_map;

layout(set = 3, binding = 0) uniform sampler2D tex_depth;
layout(set = 3, binding = 1) uniform sampler2D tex_eye_normal;
layout(set = 3, binding = 2) uniform sampler2D tex_diffuse;
layout(set = 3, binding = 3) uniform sampler2D tex_specular;
layout(set = 3, binding = 4) uniform sampler2D tex_ssao;
layout(set = 4, binding = 0) uniform sampler2D tex_depth_lowres;
layout(set = 4, binding = 1) uniform sampler2D tex_normal_lowres;

layout(location = 0) out vec4 out_color;

void main()
{
   //int pixel_offs = select_offset(tex_depth, tex_depth_lowres, in_uv);
   float ambient_occlusion = select_ambient_occlusion(tex_ssao,
                                                      tex_depth,
                                                      tex_depth_lowres,
                                                      tex_normal_lowres,
                                                      in_uv);


   INCLUDE(compute_deferred_lighting.glsl)
   //out_color = vec4(0.0, 0.0, ambient_occlusion, 1.0);
}
