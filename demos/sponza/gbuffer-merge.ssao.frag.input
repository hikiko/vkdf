#version 450

#extension GL_ARB_separate_shader_objects : enable

INCLUDE(../../data/glsl/lighting.glsl)

INCLUDE(../../data/glsl/util.glsl)

float select_offset(in sampler2D depth_tex, in sampler2D depth_low_tex, in vec2 in_uv)
{
   /* texture offset needs to be a compile time constant and so we can't
    * use a loop for the following steps, unfortunately.
    */

   float d0 = texture(depth_tex, in_uv).x;

   /* calculating the distances between the depths of the pixels
    * in the lowres neighborhood and the full res depth value
    * (texture offset must be compile time constant and so we
    * can't use a loop)
    */

   float depth1 = textureOffset(depth_low_tex, in_uv, ivec2(0, 0)).x;
   float depth2 = textureOffset(depth_low_tex, in_uv, ivec2(0, 1)).x;
   float depth3 = textureOffset(depth_low_tex, in_uv, ivec2(1, 0)).x;
   float depth4 = textureOffset(depth_low_tex, in_uv, ivec2(1, 1)).x;

   float min_depth = min(min(depth1, depth2), min(depth3, depth4));
   float max_depth = max(max(depth1, depth2), max(depth3, depth4));

   float step_distance = max_depth - min_depth;
   float s = 1.0 - step(0.0000013, step_distance);

   /* distances 
      float d1 = abs(d0 - depth1);
   float d2 = abs(d0 - depth2);
   float d3 = abs(d0 - depth3);
   float d4 = abs(d0 - depth4);

   float dmin = min(min(d1, d2), min(d3, d4));

   if (dmin == d1)
      return 0;

   if (dmin == d2)
      return 1;

   if (dmin == d3)
      return 2;

   if (dmin == d4)
      return 3; 
*/
   return s;
}

layout(push_constant) uniform pcb {
   mat4 Proj;
   float aspect_ratio;
   float tan_half_fov;
} PCB;

layout(location = 0) in vec2 in_uv;
layout(location = 1) in vec2 in_view_ray;

layout(std140, set = 0, binding = 0) uniform ubo_camera {
   mat4 View;
   mat4 ViewInv;
} CD;

layout(std140, set = 1, binding = 0) uniform light_ubo
{
   Light sun;
} L;

struct ShadowMapData {
   mat4 light_viewproj;
   uint shadow_map_size;
   uint pfc_kernel_size; /* Overriden by specialization constant */
};

layout (constant_id = 0) const int SHADOW_MAP_PCF_KERNEL_SIZE = 2;

layout(std140, set = 1, binding = 1) uniform ubo_shadow_map_data {
   ShadowMapData shadow_map_data;
} SMD;

layout(std140, set = 1, binding = 2) uniform ubo_light_eye_space_data {
   vec4 eye_pos;
   vec4 eye_dir;
} LESD;

layout(set = 2, binding = 0) uniform sampler2DShadow shadow_map;

layout(set = 3, binding = 0) uniform sampler2D tex_depth;
layout(set = 3, binding = 1) uniform sampler2D tex_eye_normal;
layout(set = 3, binding = 2) uniform sampler2D tex_diffuse;
layout(set = 3, binding = 3) uniform sampler2D tex_specular;
layout(set = 3, binding = 4) uniform sampler2D tex_ssao;
layout(set = 3, binding = 6) uniform sampler2D tex_depth_lowres;

layout(location = 0) out vec4 out_color;

void main()
{
   float pixel_offs = select_offset(tex_depth, tex_depth_lowres, in_uv);
   float ambient_occlusion = pixel_offs;

/*
   switch (pixel_offs) {
   case 0:
      ambient_occlusion = textureOffset(tex_ssao, in_uv, ivec2(0, 0)).r;
      break;
   case 1:
      ambient_occlusion = textureOffset(tex_ssao, in_uv, ivec2(0, 1)).r;
      break;
   case 2:
      ambient_occlusion = textureOffset(tex_ssao, in_uv, ivec2(1, 0)).r;
      break;
   case 3:
      ambient_occlusion = textureOffset(tex_ssao, in_uv, ivec2(1, 1)).r;
      break;
   default:
      texture(tex_ssao, in_uv).r;
      break;
   }
*/

   //INCLUDE(compute_deferred_lighting.glsl)
   // This pixel was never rendered in the gbuffer pass so use the clear
   // color
   vec4 eye_normal = texture(tex_eye_normal, in_uv);
   if (eye_normal == vec4(0.0)) {
      out_color = vec4(0.2, 0.4, 0.8, 1.0);
   } else {
      Light light = L.sun;
      light.pos = LESD.eye_pos;

      // Reconstruct eye-space position from depth buffer
      float eye_position_z = compute_eye_z_from_depth(tex_depth, in_uv, PCB.Proj);
      float eye_position_x = in_view_ray.x * eye_position_z;
      float eye_position_y = in_view_ray.y * eye_position_z;
      vec4 eye_position = vec4(eye_position_x,
                               eye_position_y,
                               eye_position_z,
                               1.0);
      vec4 eye_view_dir = -eye_position;

      /* Reconstruct light-space position for shadow mapping */
      vec4 world_pos = CD.ViewInv * eye_position;
      vec4 light_space_position = SMD.shadow_map_data.light_viewproj * world_pos;

      Material mat;
      mat.diffuse = texture(tex_diffuse, in_uv);
      mat.ambient = mat.diffuse * ambient_occlusion;
      mat.specular = texture(tex_specular, in_uv);
      mat.shininess = mat.specular.w * 255.0; /* decode from UNORM */

      // Compute lighting
      LightColor color =
         compute_lighting_directional(light,
                                      eye_position.xyz,
                                      eye_normal.xyz,
                                      eye_view_dir.xyz,
                                      mat,
                                      light.casts_shadows,
                                      light_space_position,
                                      shadow_map,
                                      SMD.shadow_map_data.shadow_map_size,
                                      SHADOW_MAP_PCF_KERNEL_SIZE);

      out_color = /*vec4(color.diffuse + color.ambient + color.specular,
                       mat.diffuse.a) */ vec4(0.0, 0.0, ambient_occlusion, 1.0);
   }
}
