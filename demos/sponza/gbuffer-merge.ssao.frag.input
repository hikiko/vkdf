#version 450

#extension GL_ARB_separate_shader_objects : enable

INCLUDE(../../data/glsl/lighting.glsl)

INCLUDE(../../data/glsl/util.glsl)

#define SSAO_DOWNSAMPLE 2.0
float nearest_depth_occlusion(in sampler2D ssao_tex,
                              in sampler2D depth_tex,
                              in sampler2D depth_low_tex,
                              in vec2 in_uv)
{
   /* texture offset needs to be a compile time constant and so we can't
    * use a loop for the following steps, unfortunately.
    */

   float d0 = texture(depth_tex, in_uv).x;

   /* calculating the distances between the depths of the pixels
    * in the lowres neighborhood and the full res depth value
    * (texture offset must be compile time constant and so we
    * can't use a loop)
    */

   float d1 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(0, 0)).x);
   float d2 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(0, 1)).x);
   float d3 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(1, 0)).x);
   float d4 = abs(d0 - textureOffset(depth_low_tex, in_uv, ivec2(1, 1)).x);

   float dmin = min(min(d1, d2), min(d3, d4));

   if (dmin == d1)
      return textureOffset(ssao_tex, in_uv, ivec2(0, 0)).x;

   if (dmin == d2)
      return textureOffset(ssao_tex, in_uv, ivec2(0, 1)).x;

   if (dmin == d3)
      return textureOffset(ssao_tex, in_uv, ivec2(1, 0)).x;

   if (dmin == d4)
      return textureOffset(ssao_tex, in_uv, ivec2(1, 1)).x;
}

float similarity(in float d1, in float d2, float scale)
{
   return clamp(1 - abs(d1 - d2) * scale, 0.0, 1.0).x;
}

const float cf16f_scale = 4096.0f * 32.0f;
float calc_ambient_occlusion(in sampler2D ssao_tex,
                             in sampler2D depth_tex,
                             in sampler2D low_depth_tex,
                             in sampler2D eye_normal_tex,
                             in sampler2D low_normal_tex,
                             in vec2 in_uv,
                             out vec4 color)
{
   vec3 eye_normal = texture(eye_normal_tex, in_uv).xyz;
   float depth = texture(depth_tex, in_uv).x;

   float depths[] = float[] (
         textureOffset(depth_tex, in_uv, ivec2(0, 0)).x,
         textureOffset(depth_tex, in_uv, ivec2(0, 1)).x,
         textureOffset(depth_tex, in_uv, ivec2(1, 1)).x,
         textureOffset(depth_tex, in_uv, ivec2(1, 0)).x);

   vec3 normals[] = vec3[] (
         textureOffset(low_normal_tex, in_uv, ivec2(0, 0)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(0, 1)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(1, 1)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(1, 0)).xyz);

   vec3 samples[] = vec3[] (
         textureOffset(ssao_tex, in_uv, ivec2(0, 0)).xyz,
         textureOffset(ssao_tex, in_uv, ivec2(0, 1)).xyz,
         textureOffset(ssao_tex, in_uv, ivec2(1, 1)).xyz,
         textureOffset(ssao_tex, in_uv, ivec2(1, 0)).xyz);

   float ndotn;
   float weight;
   float weight_sum;
   vec3 min_iter = vec3(1.0, 1.0, 1.0);

   for(int i = 0; i < 4; i++) {
      weight = similarity(depths[i] * cf16f_scale, depth, 0.003f);
      ndotn = dot(eye_normal, normals[i]);

      min_iter.r = min(samples[i].r, min_iter.r);
      min_iter.g = min(samples[i].g, min_iter.g);
      min_iter.b = min(samples[i].b, min_iter.b);

      weight *= clamp(ndotn, 0.0, 1.0);

      color += (samples[i], 1.0) * weight;
      weight_sum += weight;
   }

   color /= weight_sum;
   /*color.r = min_iter.r;
   color.g = min_iter.g;
   color.b = min_iter.b;*/
   color.rgb = min_iter.rgb;

   return mix(texture(ssao_tex, in_uv).r, color.r, 1.0 / SSAO_DOWNSAMPLE);
}

float select_ambient_occlusion(in sampler2D ssao_tex,
                               in sampler2D depth_tex,
                               in sampler2D low_depth_tex,
                               in sampler2D eye_normal_tex,
                               in sampler2D low_normal_tex,
                               in vec2 in_uv,
                               out vec4 color)
{
   vec3 eye_normal = texture(eye_normal_tex, in_uv).xyz;
   vec3 normals[] = vec3[] (
         textureOffset(low_normal_tex, in_uv, ivec2(0, 0)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(0, 1)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(1, 1)).xyz,
         textureOffset(low_normal_tex, in_uv, ivec2(1, 0)).xyz);
   float d0 = dot(eye_normal, normals[0]);
   float d1 = dot(eye_normal, normals[1]);
   float d2 = dot(eye_normal, normals[2]);
   float d3 = dot(eye_normal, normals[3]);

   float min_dot = min(min(d0, d1), min(d2, d3));
   /*
   //float d0 = dot(normals[0], normals[0]);
   float d1 = dot(normals[0], normals[1]);
   float d2 = dot(normals[0], normals[2]);
   float d3 = dot(normals[0], normals[3]);

   float min_dot = min(d1, min(d2, d3));
   */
   float bd_ao = nearest_depth_occlusion(ssao_tex, depth_tex, low_depth_tex, in_uv);
   float wa_ao = calc_ambient_occlusion(ssao_tex,
                                        depth_tex,
                                        low_depth_tex,
                                        eye_normal_tex,
                                        low_normal_tex,
                                        in_uv,
                                        color);

   return mix(bd_ao, wa_ao, step(1.0, min_dot));
}

layout(push_constant) uniform pcb {
   mat4 Proj;
   float aspect_ratio;
   float tan_half_fov;
} PCB;

layout(location = 0) in vec2 in_uv;
layout(location = 1) in vec2 in_view_ray;

layout(std140, set = 0, binding = 0) uniform ubo_camera {
   mat4 View;
   mat4 ViewInv;
} CD;

layout(std140, set = 1, binding = 0) uniform light_ubo
{
   Light sun;
} L;

struct ShadowMapData {
   mat4 light_viewproj;
   uint shadow_map_size;
   uint pfc_kernel_size; /* Overriden by specialization constant */
};

layout (constant_id = 0) const int SHADOW_MAP_PCF_KERNEL_SIZE = 2;

layout(std140, set = 1, binding = 1) uniform ubo_shadow_map_data {
   ShadowMapData shadow_map_data;
} SMD;

layout(std140, set = 1, binding = 2) uniform ubo_light_eye_space_data {
   vec4 eye_pos;
   vec4 eye_dir;
} LESD;

layout(set = 2, binding = 0) uniform sampler2DShadow shadow_map;

layout(set = 3, binding = 0) uniform sampler2D tex_depth;
layout(set = 3, binding = 1) uniform sampler2D tex_eye_normal;
layout(set = 3, binding = 2) uniform sampler2D tex_diffuse;
layout(set = 3, binding = 3) uniform sampler2D tex_specular;
layout(set = 3, binding = 4) uniform sampler2D tex_ssao;
layout(set = 4, binding = 0) uniform sampler2D tex_depth_lowres;
layout(set = 4, binding = 1) uniform sampler2D tex_normal_lowres;

layout(location = 0) out vec4 out_color;

void main()
{
   //int pixel_offs = select_offset(tex_depth, tex_depth_lowres, in_uv);
   vec4 color;
   float ambient_occlusion = select_ambient_occlusion(tex_ssao,
                                                      tex_depth,
                                                      tex_depth_lowres,
                                                      tex_eye_normal,
                                                      tex_normal_lowres,
                                                      in_uv,
                                                      color);


   INCLUDE(compute_deferred_lighting.glsl)
   //out_color = color;
  //vec3 n0 = textureOffset(tex_normal_lowres, in_uv, ivec2(0, 0)).xyz;
   //n0 = texture(tex_eye_normal, in_uv).xyz;
   //out_color = vec4(n0 * 0.5 + 0.5, 1.0);
   //out_color = vec4(color, 1.0);
   out_color = vec4(ambient_occlusion, ambient_occlusion, ambient_occlusion, 1.0);
}
